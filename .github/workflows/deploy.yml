name: Deploy to Production

# Ð¢Ñ€Ð¸Ð³Ð³ÐµÑ€ Ð½Ð° push Ð² main Ð²ÐµÑ‚ÐºÑƒ
on:
  push:
    branches:
      - main
  workflow_dispatch:  # ÐŸÐ¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð·Ð°Ð¿ÑƒÑÐºÐ°Ñ‚ÑŒ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate docker-compose syntax
        run: |
          # Create temporary env files for validation
          cp .env.prod.example .env.prod || touch .env.prod
          cp .env.prod.db.example .env.prod.db || touch .env.prod.db

          # Validate syntax
          docker compose -f docker-compose.prod.yml config > /dev/null
          echo "âœ… docker-compose.prod.yml syntax is valid"

          # Cleanup
          rm -f .env.prod .env.prod.db

      - name: Check for required files
        run: |
          required_files=(
            "Dockerfile"
            "docker-compose.prod.yml"
            "entrypoint.sh"
            "requirements.prod.txt"
            "nginx/default.conf"
          )

          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Required file missing: $file"
              exit 1
            fi
          done
          echo "âœ… All required files present"

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: validate

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          echo "Building Docker image..."
          docker build -t insurance-broker:latest .
          echo "âœ… Docker image built successfully"

      - name: Verify image exists
        run: |
          echo "Checking if image exists..."
          docker images | grep insurance-broker
          echo "âœ… Image verified"

      - name: Test Docker image
        run: |
          echo "Testing Docker image..."
          docker run --rm --entrypoint python insurance-broker:latest --version
          echo "âœ… Docker image is functional"

  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $DROPLET_HOST >> ~/.ssh/known_hosts
          echo "âœ… SSH configured"

      - name: Copy files to server
        env:
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          rsync -avz -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            --exclude='.git' \
            --exclude='venv' \
            --exclude='black_venv' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.env' \
            --exclude='.env.prod' \
            --exclude='.env.prod.db' \
            --exclude='db.sqlite3' \
            --exclude='certbot/' \
            ./ $DROPLET_USER@$DROPLET_HOST:~/insurance_broker/
          echo "âœ… Files copied to server (preserving credentials and certificates)"

      - name: Verify env files on server
        env:
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_HOST << 'ENDSSH'
            set -e
            cd ~/insurance_broker

            # Check if .env.prod.db exists
            if [ ! -f .env.prod.db ]; then
              echo "âŒ .env.prod.db not found!"
              echo "Please create it manually on the server before deploying"
              exit 1
            else
              echo "âœ… .env.prod.db exists (preserving existing credentials)"
            fi

            # Check if .env.prod exists
            if [ ! -f .env.prod ]; then
              echo "âŒ .env.prod not found!"
              echo "Please create it manually on the server before deploying"
              exit 1
            else
              echo "âœ… .env.prod exists (preserving existing credentials)"
            fi

            echo "âœ… Environment files verified (not modified)"
          ENDSSH

      - name: Deploy on server
        env:
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          # Note: Server uses docker-compose (v1 with hyphen), not docker compose (v2)
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_HOST << 'ENDSSH'
            set -e
            cd ~/insurance_broker

            echo "ðŸ“¦ Pulling latest images..."
            docker-compose -f docker-compose.prod.yml pull || true

            echo "ðŸ”¨ Building images..."
            docker-compose -f docker-compose.prod.yml build

            echo "ðŸ”„ Restarting containers with new images..."
            docker-compose -f docker-compose.prod.yml up -d --force-recreate --no-deps web celery_worker celery_beat

            echo "â³ Waiting for services to be ready..."
            sleep 15

            echo "ðŸ”„ Restarting nginx to pick up any config changes..."
            docker-compose -f docker-compose.prod.yml restart nginx

            echo "âœ… Deployment completed"
          ENDSSH

      - name: Run migrations
        env:
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_HOST << 'ENDSSH'
            set -e
            cd ~/insurance_broker

            echo "ðŸ”„ Running database migrations..."
            docker-compose -f docker-compose.prod.yml exec -T web python manage.py migrate --noinput

            echo "ðŸ“¦ Collecting static files..."
            docker-compose -f docker-compose.prod.yml exec -T web python manage.py collectstatic --noinput

            echo "âœ… Migrations completed"
          ENDSSH

      - name: Health check
        env:
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_HOST << 'ENDSSH'
            set -e
            cd ~/insurance_broker

            echo "ðŸ¥ Checking container health..."
            docker-compose -f docker-compose.prod.yml ps

            # Check if web container is running
            if ! docker-compose -f docker-compose.prod.yml ps | grep -q "web.*Up"; then
              echo "âŒ Web container is not running"
              docker-compose -f docker-compose.prod.yml logs web
              exit 1
            fi

            # Check if db container is running
            if ! docker-compose -f docker-compose.prod.yml ps | grep -q "db.*Up"; then
              echo "âŒ Database container is not running"
              docker-compose -f docker-compose.prod.yml logs db
              exit 1
            fi

            echo "âœ… All containers are healthy"
          ENDSSH

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate, build, deploy]
    if: always()

    steps:
      - name: Deployment Success
        if: needs.deploy.result == 'success'
        run: |
          echo "âœ… Deployment to production was successful!"
          echo "ðŸŒ Application should be available at https://onbr.site"

      - name: Deployment Failure
        if: needs.deploy.result == 'failure' || needs.build.result == 'failure' || needs.validate.result == 'failure'
        run: |
          echo "âŒ Deployment failed!"
          echo "Please check the logs above for details."
          exit 1

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: deploy
    if: failure()

    steps:
      - name: Setup SSH for rollback
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $DROPLET_HOST >> ~/.ssh/known_hosts

      - name: Rollback to previous version
        env:
          DROPLET_HOST: ${{ secrets.DROPLET_HOST }}
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_HOST << 'ENDSSH'
            set -e
            cd ~/insurance_broker

            echo "âš ï¸  Deployment failed, attempting rollback..."

            # Try to restart with previous images
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml up -d

            echo "ðŸ”„ Rollback completed - previous version restored"
          ENDSSH

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

      - name: Notify rollback
        run: |
          echo "âš ï¸  Deployment failed and rollback was executed"
          echo "Previous version has been restored"
          exit 1
